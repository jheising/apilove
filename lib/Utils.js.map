{"version":3,"file":"Utils.js","sourceRoot":"","sources":["Utils.ts"],"names":[],"mappings":";;AAAA,mCAAuE;AACvE,mDAAmD;AAEnD;IAEI,MAAM,CAAC,cAAc,CAAC,GAAG;QACrB,OAAO,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC5D,CAAC;IAED,MAAM,CAAC,aAAa,CAAC,KAAU,EAAE,aAAqB;QAElD,IAAG,cAAK,CAAC,aAAa,CAAC,EACvB;YACI,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,cAAc,CAAC;QACnB,IAAI,YAAY,GAAG,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;QAE/C,uBAAuB;QACvB,IAAG,YAAY,KAAK,aAAa,EACjC;YACI,OAAO,KAAK,CAAC;SAChB;QAED,2DAA2D;QAC3D,IAAG,YAAY,KAAK,QAAQ,IAAI,YAAY,KAAK,OAAO,EACxD;YACI,IAAG,aAAa,KAAK,QAAQ,EAC7B;gBACI,IAAI;oBACA,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;iBAChC;gBACD,OAAO,CAAC,EAAE;iBACT;aACJ;YAED,OAAO,SAAS,CAAC;SACpB;QAED,QAAQ,aAAa,EAAE;YACnB,KAAK,QAAQ,CAAC,CAAC;gBACX,cAAc,GAAG,iBAAQ,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM;aACT;YACD,KAAK,SAAS,CAAC,CAAC;gBACZ,cAAc,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBACxC,MAAM;aACT;YACD,KAAK,QAAQ,CAAC,CAAC;gBACX,cAAc,GAAG,iBAAQ,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM;aACT;YACD,KAAK,OAAO,CAAC,CAAC;gBACV,cAAc,GAAG,kBAAS,CAAC,KAAK,CAAC,CAAC;gBAClC,MAAM;aACT;YACD,KAAK,QAAQ,CAAC,CAAC;gBACX,IAAI;oBACA,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;iBACtC;gBACD,OAAO,CAAC,EAAE;oBACN,cAAc,GAAG,KAAK,CAAC;iBAC1B;aACJ;SACJ;QAED,OAAO,cAAc,CAAC;IAC1B,CAAC;IAED,MAAM,CAAC,SAAS,CAAC,KAAU;QACvB,IAAI,kBAAS,CAAC,KAAK,CAAC,EAAE;YAClB,OAAO,KAAK,CAAC;SAChB;QAED,OAAO,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,CAAC,QAAQ,CAAC,GAAG,SAAgB;QAE/B,KAAK,IAAI,QAAQ,IAAI,SAAS,EAAE;YAC5B,IAAI,CAAC,cAAK,CAAC,QAAQ,CAAC,IAAI,QAAQ,IAAI,EAAE,EAAE;gBACpC,OAAO,QAAQ,CAAC;aACnB;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,MAAM,CAAC,qBAAqB,CAAC,EAAY;QACrC,OAAO,YAAY,CAAC,EAAE,CAAC,CAAC;IAC5B,CAAC;IAED,MAAM,CAAC,uBAAuB,CAAC,KAAY,EAAE,QAAgD;QAEzF,IAAG,KAAK,EACR;YACI,IAAG,QAAQ;gBAAE,QAAQ,CAAC,KAAK,CAAC,CAAC;YAC7B,OAAO,IAAI,CAAC;SACf;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;CACJ;AApGD,sBAoGC","sourcesContent":["import {isBoolean, isNil, toString, castArray, toNumber} from \"lodash\";\nimport * as getArguments from \"function-arguments\";\n\nexport class Utils {\n\n    static getRawTypeName(obj){\n        return Object.prototype.toString.call(obj).slice(8, -1);\n    }\n\n    static convertToType(value: any, convertToType: string):any {\n\n        if(isNil(convertToType))\n        {\n            return value;\n        }\n\n        let convertedValue;\n        let rawValueType = Utils.getRawTypeName(value);\n\n        // No conversion needed\n        if(rawValueType === convertToType)\n        {\n            return value;\n        }\n\n        // Objects and Arrays can only be converted to JSON strings\n        if(rawValueType === \"Object\" || rawValueType === \"Array\")\n        {\n            if(convertToType === \"String\")\n            {\n                try {\n                    return JSON.stringify(value);\n                }\n                catch (e) {\n                }\n            }\n\n            return undefined;\n        }\n\n        switch (convertToType) {\n            case \"String\": {\n                convertedValue = toString(value);\n                break;\n            }\n            case \"Boolean\": {\n                convertedValue = Utils.toBoolean(value);\n                break;\n            }\n            case \"Number\": {\n                convertedValue = toNumber(value);\n                break;\n            }\n            case \"Array\": {\n                convertedValue = castArray(value);\n                break;\n            }\n            case \"Object\": {\n                try {\n                    convertedValue = JSON.parse(value);\n                }\n                catch (e) {\n                    convertedValue = value;\n                }\n            }\n        }\n\n        return convertedValue;\n    }\n\n    static toBoolean(input: any) {\n        if (isBoolean(input)) {\n            return input;\n        }\n\n        return (/(1|true|yes)/i).test(input);\n    }\n\n    static coalesce(...inputArgs: any[]) {\n\n        for (let inputArg of inputArgs) {\n            if (!isNil(inputArg) && inputArg != \"\") {\n                return inputArg;\n            }\n        }\n\n        return null;\n    }\n\n    static getFunctionParamNames(fn: Function): string[] {\n        return getArguments(fn);\n    }\n\n    static shouldCallbackWithError(error: Error, callback: (error: Error, ...args: any[]) => void): boolean {\n\n        if(error)\n        {\n            if(callback) callback(error);\n            return true;\n        }\n\n        return false;\n    }\n}"]}