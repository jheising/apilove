{"version":3,"file":"S3FileService.js","sourceRoot":"","sources":["S3FileService.ts"],"names":[],"mappings":";;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8DG","sourcesContent":["import {FileService} from \"../FileService\";\nimport * as path from \"path\";\nimport * as aws from \"aws-sdk\";\nimport {APIConfig} from \"../../../APIConfig\";\n\n/*export class S3FileService implements FileService {\n\n    private static _s3Client;\n    static get s3Client() {\n        if (!S3FileService._s3Client) {\n            S3FileService._s3Client = new aws.S3();\n        }\n\n        return S3FileService._s3Client;\n    }\n\n    writeFile(relativePath: string, contents: string, callback: (error?: Error) => void) {\n        S3FileService.s3Client.putObject({\n            Bucket: APIConfig.S3_FILE_SERVICE_ROOT_PATH,\n            Key: relativePath,\n            Body: contents\n        }, function (err, data) {\n            MaskedError.processCallback(err, callback);\n        });\n    }\n\n    readFile(relativePath: string, callback: (error: Error, contents: string) => void) {\n        S3FileService.s3Client.getObject({\n            Bucket: this._bucketName,\n            Key: relativePath\n        }, function (err, data) {\n            if (MaskedError.shouldCallbackWithError(err, callback)) return;\n            if (callback) callback(null, data.Body.toString());\n        });\n    }\n\n    fileExists(relativePath: string, callback: (error: Error, exists: boolean) => void)\n    {\n        S3FileService.s3Client.headObject({\n            Bucket: this._bucketName,\n            Key: relativePath\n        }, function (err, data) {\n            callback(null, !(err || _.isNil(data)));\n        });\n    }\n\n    listDirectoriesInPath(relativePath: string, callback: (error: Error, directories: string[]) => void) {\n        relativePath = path.join(relativePath, \"/\");\n\n        S3FileService.s3Client.listObjectsV2({\n            Bucket: this._bucketName,\n            Delimiter: '/',\n            Prefix: relativePath\n        }, function (err, data) {\n\n            if (MaskedError.shouldCallbackWithError(err, callback)) return;\n\n            let directories = [];\n\n            for (let key of data.CommonPrefixes) {\n                let pathElements = path.relative(relativePath, key.Prefix).split(\"/\");\n                directories.push(pathElements[0]);\n            }\n\n            if(callback) callback(null, directories);\n        });\n    }\n}*/"]}